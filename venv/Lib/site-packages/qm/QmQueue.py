from enum import Enum
from typing import Optional, List

from google.protobuf import empty_pb2

from qm.QmPendingJob import QmPendingJob
from qm._errors import FailedToAddJobToQueueException
from qm.pb.frontend_pb2 import JobQueryParams, QueryValueMatcher, AddToQueueRequest, QueuePosition
from qm._logger import logger
from qm.program import _Program
from qm.utils import _level_map, _set_compiler_options


class JobNotFoundError(Exception):
    pass


class _QueuePosition(Enum):
    Start = 1
    End = 2


class QmQueue(object):
    def __init__(self, machine, qmm: 'qm.QuantumMachinesManager.QuantumMachinesManager'):
        self._machine = machine
        self._qmm = qmm

    def _get_pending_jobs(self, job_id: str = None, position: int = None, user_id: str = None) -> List[QmPendingJob]:
        request = JobQueryParams()
        request.quantumMachineId = self._machine.id
        if job_id is not None:
            job_query_value_matcher = QueryValueMatcher()
            job_query_value_matcher.value = job_id
            request.jobId.CopyFrom(job_query_value_matcher)
        if position is not None:
            request.position.value = position
        if user_id is not None:
            user_query_value_matcher = QueryValueMatcher()
            user_query_value_matcher.value = user_id
            request.userId.CopyFrom(user_query_value_matcher)

        response = self._qmm._frontend.GetPendingJobs(request)
        jobs = [(i, response.pendingJobs[i].positionInQueue) for i in list(response.pendingJobs)]
        jobs.sort(key=lambda it: it[1])
        result = [QmPendingJob(pending_job_id, self._machine, self._qmm) for pending_job_id,pos in jobs]
        return result

    def add(self, program: _Program, **kwargs) -> QmPendingJob:
        """
        Add a QMJob to the queue
        :param program: A QUA program

        Example::

        >>> qm.queue.add(program)  # adds at the end of the queue
        >>> qm.queue.insert(program, position)  # adds at position
        """
        return self._insert(program, _QueuePosition.End, **kwargs)

    def add_to_start(self, program: _Program, **kwargs) -> QmPendingJob:
        """
        Add a QMJob to the start of the queue

        :param program: A QUA program

        """
        return self._insert(program, _QueuePosition.Start, **kwargs)

    def _insert(self, program: _Program, position: _QueuePosition, **kwargs) -> QmPendingJob:
        request = AddToQueueRequest()
        request.quantumMachineId = self._machine.id
        request.highLevelProgram.CopyFrom(program.build(self._machine._pb_config))

        _set_compiler_options(request, **kwargs)

        logger.info("Executing high level program")

        queue_position = QueuePosition()
        if position == _QueuePosition.Start:
            queue_position.start.CopyFrom(empty_pb2.Empty())
        elif position == _QueuePosition.End:
            queue_position.end.CopyFrom(empty_pb2.Empty())

        request.queuePosition.CopyFrom(queue_position)
        response = self._qmm._frontend.AddToQueue(request)

        messages = [
            (_level_map[msg.level], msg.message) for msg in response.messages
        ]

        job_id = response.jobId

        for lvl, msg in messages:
            logger.log(lvl, msg)

        if not response.ok:
            logger.error("Job " + job_id + " failed. Failed to execute program.")
            raise FailedToAddJobToQueueException(job_id)

        return QmPendingJob(job_id, self._machine, self._qmm)

    @property
    def count(self):
        """
        Get the number of jobs currently on the queue

        Example::

        >>> qm.queue.count
        """
        return len(self._get_pending_jobs())

    def __len__(self):
        return self.count

    @property
    def pending_jobs(self) -> List[QmPendingJob]:
        return self._get_pending_jobs()

    def get(self, job_id) -> QmPendingJob:
        """
        Get a PendingQmJob object by job_id
        :param job_id: a QMJob id

        Example::

        >>> qm.queue.get(job_id)

        """
        jobs = self._get_pending_jobs(job_id)
        if len(jobs) == 0:
            raise JobNotFoundError()
        return jobs[0]

    def get_at(self, position: int) -> QmPendingJob:
        """
        Get a PendingQmJob object by position in queue

        :param position: An integer position in queue

        Example::

        >>> qm.queue.get(job_id)

        """
        jobs = self._get_pending_jobs(None, position)
        if len(jobs) == 0:
            raise JobNotFoundError()
        return jobs[0]

    def get_by_user_id(self, user_id: str) -> List[QmPendingJob]:
        return self._get_pending_jobs(None, None, user_id)

    def remove_by_id(self, job_id: str) -> int:
        """
        Remove the PendingQmJob object with a specific job id
        :param job_id: a QMJob id

        Example::

        >>> qm.queue.remove_by_id(job_id)
        """
        if job_id is None or job_id == "":
            raise ValueError("job_id can not be empty")
        return self._remove(job_id=job_id, position=None, user_id=None)

    def remove_by_position(self, position: int) -> int:
        """
        Remove the PendingQmJob object by position in queue
        :param position: position in queue

        Example::

        >>> qm.queue.remove_by_position(position)

        """
        if position is None or position <= 0:
            raise ValueError("position must be positive")
        return self._remove(job_id=None, position=position, user_id=None)

    def remove_by_user_id(self, user_id: str):
        return self._remove(job_id=None, position=None, user_id=user_id)

    def _remove(self, job_id: Optional[str] = None, position: Optional[int] = None, user_id: Optional[str] = None) -> int:
        request = JobQueryParams()
        request.quantumMachineId = self._machine.id
        if job_id is not None:
            job_query_value_matcher = QueryValueMatcher()
            job_query_value_matcher.value = job_id
            request.jobId.CopyFrom(job_query_value_matcher)

        if position is not None:
            request.position.value = position

        if user_id is not None:
            user_query_value_matcher = QueryValueMatcher()
            user_query_value_matcher.value = user_id
            request.userId.CopyFrom(user_query_value_matcher)

        response = self._qmm._frontend.RemovePendingJobs(request)
        return response.numbersOfJobsRemoved

    def __getitem__(self, position) -> QmPendingJob:
        return self.get_at(position)

    def clear(self) -> int:
        return self._remove()
